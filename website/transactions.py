from flask import Blueprint, render_template, redirect, url_for, request, flash, jsonify, send_file, current_app, send_from_directory
from .models import User, Transaction, TransactionReceipt, IndivTransaction
from . import db
from datetime import datetime, time, timedelta
from flask_login import login_required, current_user

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from io import BytesIO
from reportlab.lib import colors
from reportlab.platypus import Table, TableStyle
import os
from sqlalchemy import func

transactions = Blueprint('transactions', __name__)


@transactions.route('/txns')
@login_required
def transactionsPage():

    users = User.query.all() 
    transactions=TransactionReceipt.query.all()
    amtTransaction=Transaction.query.all()
    indixtxn = IndivTransaction.query.all()

    if current_user.access == 'Admin':
        return render_template("transactions.html", users=users, transactions=transactions, amtTransaction=amtTransaction, indixtxn=indixtxn)
    
    else: 
        flash('You are not authorized to view this page.', category='error')    
        return render_template("restricted.html", boolean=True)
@transactions.route('/generate_report', methods=['POST'])
@login_required
def generate_report():
    if request.method == 'POST':
        startDate = request.form.get('startDate')
        endDate = request.form.get('endDate')

        try:
            # Add a day to the end date to include transactions up to and including the end date
            end_date = datetime.strptime(endDate, '%Y-%m-%d') + timedelta(days=1)
            endDate = end_date.strftime('%Y-%m-%d')

            # Fetch distinct latest transaction receipts within the date range
            subquery = db.session.query(
                func.max(TransactionReceipt.created_at).label('max_created_at'),
                TransactionReceipt.transaction_id
            ).filter(
                TransactionReceipt.created_at.between(startDate, endDate)
            ).group_by(TransactionReceipt.transaction_id).subquery()

            transaction_receipts = db.session.query(TransactionReceipt).join(
                subquery, 
                db.and_(
                    TransactionReceipt.transaction_id == subquery.c.transaction_id,
                    TransactionReceipt.created_at == subquery.c.max_created_at
                )
            ).all()

            # Extract transaction IDs from filtered receipts
            transaction_ids = [receipt.transaction_id for receipt in transaction_receipts]

            # Fetch all transactions corresponding to the retrieved IDs
            transactions_query = Transaction.query.filter(
                Transaction.transaction_id.in_(transaction_ids)
            ).all()

            buffer = BytesIO()
            report = canvas.Canvas(buffer, pagesize=letter)
            pagewidth = report._pagesize[0]

            report.setTitle("Sales Report")
            report.setFont("Helvetica-Bold", 12)
            report.drawCentredString(300, 750, "THE CRAZY FISH MAN")
            report.drawCentredString(300, 735, "Sales Report")
            report.setFont("Helvetica", 10)
            report.drawCentredString(300, 720, f"Date Range: {startDate} - {endDate}")
            report.drawString(50, 20, f"Report Generated at {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
            report.drawRightString(pagewidth - 40, 20, f"Report Generated by {current_user.first_name} {current_user.last_name} ({current_user.eid})")

            col_widths = [100, 100, 100, 100]
            row_height = 20
            x = 100
            y = 650
            report.setFont('Helvetica-Bold', 10)
            report.drawString(x, y, "Date")
            report.drawString(x + col_widths[0], y, "Transaction ID")
            report.drawString(x + col_widths[0] + col_widths[1], y, "Amount")
            report.drawString(x + col_widths[0] + col_widths[1] + col_widths[2], y, "User")
            y -= row_height

            report.setFont("Helvetica", 10)
            for receipt in transaction_receipts:
                report.drawString(x, y, receipt.created_at.strftime('%Y-%m-%d'))
                report.drawString(x + col_widths[0], y, str(receipt.transaction_id))
                
                corresponding_transaction = next((t for t in transactions_query if t.transaction_id == receipt.transaction_id), None)
                if corresponding_transaction:
                    report.drawString(x + col_widths[0] + col_widths[1], y, str(corresponding_transaction.total_amount))
                    report.drawString(x + col_widths[0] + col_widths[1] + col_widths[2], y, str(receipt.tuserlog))  # Assuming tuserlog is a string attribute
                y -= row_height
            
            total_amount = sum(transaction.total_amount for transaction in transactions_query)
            report.setFont("Helvetica-Bold", 12)
            report.drawString(x + col_widths[0] + col_widths[1], y - 20, f"Total Sales: {total_amount}")

            report.save()
            buffer.seek(0)

            return send_file(
                buffer,
                as_attachment=True,
                download_name=f"TCFM_Transactions_Report_{startDate}_{endDate}.pdf",
                mimetype='application/pdf'
            )

        except Exception as e:
            flash(f"Error generating report: {str(e)}", category='error')
            return redirect(url_for('transactions.transactionsPage'))

    
@transactions.route('/website/receipts/<filename>')
@login_required
def download_receipt(filename):
    directory = os.path.join(current_app.root_path, 'receipts')
    return send_from_directory(directory, filename)
